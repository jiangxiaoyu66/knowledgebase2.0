## 传输层（TCP和UDP）

### TCP和UDP的区别

- TCP是**面向连接的、可靠的、基于字节流**的传输层协议
- UDP是一个**面向无连接**的传输层协议

**详细区别：**

1.
    tcp基于连接，所以可靠性高；但也正因为如此，需要**三次握手**，重新确认等连接过程，所以实时性差，有延迟；

    udp基于无连接，所以可靠性低；但是因为没有连接的过程，所以实时性强

2.
    tcp连接只能是**一对一**的；udp支持一对一，一对多，多对多的交互通信
3.
    udp**传输数据容量**比tcp大

    在传输相同大小的数据时，tcp首部开销20字节；udp首部开销只有8个字节，tcp报头比udp复杂，故实际包含的用户数据较少。

4.
    TCP在IP协议的基础上添加了**序号机制、确认机制、超时重传机制**等，保证了传输的可靠性，不会出现丢包或乱序。所以TCP性能开销比较大。
    

    而UDP没有相关机制保证数据完整性，所以可能因为网络会有丢包现象，另外因为不管相关机制，所以性能消耗比TCP小得多

应用场景的区别：
    在不追求数据完整性的时候使用TCP；在追求实时性时候使用UDP


### TCP

TCP三大核心：

1. 面向连接；所谓面向连接，指的是客户端与服务端的连接，在双方互相通信之前，TCP需要三次握手简历连接，而UDP没有相应的简历连接的过程

2. 可靠性；TCP可靠性主要体现在

   **有状态**：TCP会精准记录哪些数据发送了，被对方接受了，哪些没有，而保证数据按序到达，不允许差错

   **可控制**：意识到丢包或者网络环境差，TCP根据具体情况调整自己的行为，控制自己发送速度或重发

3. 面向字节流；UDP数据传输基于数据报，仅仅是继承了IP层的特性，而TCP为维护状态，将IP包变成了字节流

#### TCP三次握手

tcp标志位有6种标志：

SYN(synchronous建立联机) 

ACK(acknowledgement 确认) 

PSH(push传送) 

FIN(finish结束)

RST(reset重置) 

URG(urgent紧急)



而对应SYN和ACK的分别是Sequence number(顺序号码) 和Acknowledge number(确认号码)

--------



第一次握手：客户端发送位码syn=1，随机产生seq number=1234567。服务端由syn=1知道，客户端要求建立连接。

第二次握手：服务端在收到syn=1后知道客户端请求连接，所以向客户端发送ack=1，syn=1，ack number=(1234567+1), 随机的seq number=(123456) 的包

第三次握手：客户端检查ack number是否正确（即第一次发送的seq number+1），ack是否为1。

若正确，客户端再次发送ack=1，ack number=（123456+1）。服务端收到后确认ack和ack number，正确则建立连接成功

参考文章：[TCP三次握手中SYN，ACK，Seq三者的关系](https://blog.csdn.net/u014507230/article/details/45310847)



**为什么是3次握手，不是2次握手？**

**2次握手只能确认客户端的发送功能和服务器的接收功能没有问题；但是不能保证客户端的接收功能和服务端的发送功能是否正常。**

>参考：[**TCP.md**](https://github.com/ChellyAI/note/blob/master/HTTP/3%E3%80%81TCP.md)
>
> 这是为了确认在即将建立连接时，两端都处于准备建立连接的状态，防止失效的连接请求报文被服务器接收而产生错误。**通过三次握手，能够让双方都知道彼此的接收能力、发送能力没问题**。
>
>  假设客户端发送请求连接报文A，因为网络原因超时，此时TCP启动超时重传机制，再次发送连接请求报文B，顺利到达服务端并建立连接。结束连接后，服务端又收到报文A，此时若不同客户端确认，直接进入**ESTABLISHED**状态并发送同意连接报文至客户端，而客户端已经处于**CLOSED**状态，因此连接不会建立且服务端一直处于等待状态，造成资源浪费。
>
>  举个例子，两个人发微信聊天，如果A对B说“听得到吗”，B回复A“听得到”，正常情况下这两次交流就可以确认并开始互发消息。但假如第一次A问“听得到吗”的时候在隧道内，导致消息并未及时发出去，而A就把微信关闭了，当B接收到A后回复一句“听得到”并做好准备聊天，导致空等。而如果A收到B的回复后再回一句“好的好的，咱开始吧”，让B知道A现在也准备好了，加一道保险，更加安全。

**为什么不是四次？**

因为三次已经足够确认双方的发送和接收的能力了，四次以及四次以上当然就没必要啦

**三次握手过程中可以携带数据吗？**

可以，但是只有第三次，此时的`established`状态相对安全并且够确认服务器的接收发送能力。

而不能在第一次握手携带数据是为了防止黑客在`syn`中放入大量数据造成服务器资源的消耗。



#### TCP四次挥手

参考：[面试官，不要再问我三次握手和四次挥手](https://juejin.cn/post/6844903958624878606#heading-6)

1. 客户端发送一个 FIN 报文，报文中会指定一个顺序号码。此时客户端处于 `FIN_WAIT1` 状态。 

   即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入`FIN_WAIT1`（终止等待1）状态，等待服务端的确认。

2. 服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。 

   即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

   

3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。 

   即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

4. 第三次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。 

   即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

> 注意了，这个时候，客户端需要等待两个 `MSL`(Maximum Segment Lifetime，报文最大生存时间),在这段时间内如果客户端没有收到服务端的重发请求，那么表示 `ACK `成功到达，挥手结束。否则客户端重发 ACK。

![16da9fd28b49f652](图片-05. TCP和UDP的区别/16da9fd28b49f652.png)

**为什么要等待 2 MSL?**

参考：[为什么TCP4次挥手时等待为2MSL？](https://www.zhihu.com/question/67013338)

当客户端发送ACK=1的报文后，客户端不知道服务端是否真的接收到自己的ACK，所以对于客户端来说：

（1）如果服务端没有收到自己的ACK，服务端自己会超时重传FiN

那么客户端再次接到重传的FIN，会再次发送ACK

（2）如果服务端收到了自己的ACK，也不会再发任何消息，包括ACK

无论是(1)还是(2)，客户端都需要等待，要取这两种情况等待时间的最大值，**以应对最坏的情况发生**，这个最坏情况是：

去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。

这恰恰就是**2MSL( Maximum Segment Life)。**

**为什么是四次挥手而不是三次？**

- 因为服务端在接收到`FIN`, 往往不会立即返回`FIN`, 必须等到服务端所有的报文都发送完毕了，才能发`FIN`。
- 因此先发一个ACK表示已经收到客户端的`FIN`，延迟一段时间才发`FIN`。这就造成了四次挥手。 `如果是三次挥手会有什么问题？` 等于说服务端将`ACK`和`FIN`的发送合并为一次挥手，长时间的延迟可能会导致客户端误以为`FIN`没有到达客户端，从而让客户端不断的重发`FIN`。

