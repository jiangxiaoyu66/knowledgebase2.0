## Http协议

Http属于应用层，从1991年发展至今，迭代了几个版本，0.9，1.0，1.1，2.0.那我们就按照时间线依次说一说每个版本新增的特性吧

### 0.9

只能接受GET的请求方式，服务器返回的只能是html格式的字符串

### 1.0

新增了POST的请求方式，除了文字还可以传图像，视频，二进制文件。

请求和回应都新增了请求头和协议的版本。回应头信息的内部有Content-Type(数据格式),Content-Encoding（数据压缩方法）。

缺点是:每次TCP链接只能发送一个请求，下一个请求需要再一次进行TCP链接，因为有三次握手的缘故，TCP链接比较占用性能，随着网页加载的资源越来越多，问题也越来越暴露出来。虽然引入了connection:keep-alive的字段，但它属于非标准字段，可能会因为不同的实现方式出现不同的结果，所以不属于根本性的解决方案。



### 1.1

新增持久连接，即无需依赖connection字段指定，TCP链接默认是不关闭的，服务端可以一次接受多个请求。

管道机制，客户端可以一次发送多个请求。

有了持久链接，客户端就不需要等待tcp连接重开后再发下一次请求。有了管道连接，客户端也就不需要再同一个TCP链接中，等待上由此请求发送成功，服务端做出回应后再发下一次请求，可以直接发。只不过再服务端那边还是按照请求发送的顺序依次做出回应。

分块传输：

配合content-length字段，每一块都有自己的数据长度，如果数据长度达到了Content-Length，则进行下一块的传输，知道content-length为0为止。

还新增了更多请求方法：

DELETE,PUT,

HEAD（和GET一样，用于单纯的请求资源，但是HEAD的请求方式指只会返回响应头，一般用于读取服务器的性能）,

OPTIONS（和HEAD类似，用来获取服务器支持的所有请求方式，也可以判断是否对指定资源有访问权限）,

PATCH（PATCH和PUT的区别是PUT用于资源的整体更新，而PATCH用于资源的部分更新）

缺点：

虽然1.1版本允许TCP复用连接，但是服务器只会按照请求顺序对请求做出回应，容易造成队头阻塞，即第一个数据包受阻而导致的整个数据包受阻。

如何避免？减少请求数或者多开持久连接。

09年，为了解决HTTP1.0效率不高的问题，谷歌公开了自主研发的SPDY协议。

### 2.0

多工：为了解决1.1中队头阻塞的风险，2.0新推出多工的概念。什么叫作多工呢，就是在同一个TCP连接中，如果两个A和B，A和B，如果A先请求，但是由于时间过长，就先把A请求中已经处理好的数据回应给A，然后处理B请求。等到B请求完成后再处理A请求。

但是伴随这个的还有一个问题，就是因为多工的原因，现在的数据流不再一定是按照顺序发送的。那么如何将数据包和数据流对应起来呢（数据包：由于1.1版本的分块传输，导致每个数据流会被分为多块进行传输，这里的每一块在2.0里被称为数据包，数据流就是每个请求返回的**完整**数据）。所有的数据包都会对应一个他的数据流ID，用来区分谁属于谁。且客户端数据流的ID是奇数，服务端数据流的ID为偶数）



另一方面，为了提高传输效率，对头信息做了两个处理：

1.把头信息从原来的文本格式改为二进制格式，提高解析速度。且将二进制的头信息和二进制的数据体统称为“帧”，包括“头信息帧”和“数据帧”

2.使用gzip或者compress压缩头信息

3.客户端和服务端维护同一张头信息表，头信息中的所有字段全部有一个对应的索引号。后面同样的字段就 不发字段了，直接发索引号。

服务器推送，即允许服务器无需客户端发请求，主动向客户端推送资源。一般用在服务端觉得客户端会继续请求大量静态资源的时候，他会主动把资源推给客户端。



## 总结

https://juejin.cn/post/6923774803669155847

### http0.9

特点：

- 请求端只支持 GET 请求
- 响应端只能返回 HTML 文本数据

HTTP/0.9 痛点：

- 请求方式唯一，返回格式唯一
- TCP 连接无法复用

### http1.0

核心特点如下：

- 请求端增加 HTTP 协议版本，响应端增加状态码。
- 请求方法增加 POST、HEAD。
- 请求端和响应端增加头部字段。
  - Content-Type 让响应数据不只限于超文本。
  - Expires、Last-Modified 缓存头。
  - Authorization 身份认证。
  - Connection: keep-alive 支持长连接，但非标准。

HTTP/1.0 痛点：

- TCP 连接无法复用。
- HTTP 队头阻塞，一个 HTTP 请求响应结束之后，才能发起下一个 HTTP 请求。
- 一台服务器只能提供一个 HTTP 服务。



### HTTP/1.1

特点如下：

- 持久连接。
  - HTTP/1.1 默认开启持久连接，在 TCP 连接建立后不立即关闭，让多个 HTTP 请求得以复用。
- 管线化技术。
  - HTTP/1.1 中，多个 HTTP 请求不用排队发送，可以批量发送，这就解决了 HTTP 队头阻塞问题。但批量发送的 HTTP 请求，必须按照发送的顺序返回响应，相当于问题解决了一半，仍然不是最佳体验。
- 支持响应分块。
  - HTTP/1.1 实现了流式渲染，响应端可以不用一次返回所有数据，可以将数据拆分成多个模块，产生一块数据，就发送一块数据，这样客户端就可以同步对数据进行处理，减少响应延迟，降低白屏时间。
  - Bigpipe 的实现就是基于这个特性，具体是通过定义 `Transfer-Encoding` 头来实现的。
- 增加 Host 头。
  - HTTP/1.1 实现了虚拟主机技术，将一台服务器分成若干个主机，这样就可以在一台服务器上部署多个网站了。
  - 通过配置 Host 的域名和端口号，即可支持多个 HTTP 服务： `Host: <domain>:<port>`
- 其他扩展。
  - 增加 Cache-Control、E-Tag 缓存头。
  - 增加 PUT、PATCH、HEAD、 OPTIONS、DELETE 请求方法。

HTTP/1.1 痛点：

- HTTP 队头阻塞没有彻底解决，响应端必须按照 HTTP 的发送顺序进行返回，如果排序靠前的响应特别耗时，则会阻塞排序靠后的所有响应。

### **HTTP 2.0**

- **二进制分帧**：头信息和数据体都是二进制，统称为“帧”，头部信息帧和数据帧。将请求及响应包含的信息拆分为多个帧，对其顺序标识后乱序发送，首部封装到 `HEADER frame` 中，请求体封装到 `DATA frame` 中，各帧之间互不依赖、互不干扰
- **多路复用**：复用 `TCP` 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。
- **头部压缩**： `HTTP 1.1` 版本会出现 `「User-Agent、Cookie、Accept、Server、Range」` 等字段可能会占用几百甚至几千字节，而 `Body` 却经常只有几十字节，所以导致头部偏重。`HTTP 2.0` 使用 `HPACK` 算法进行压缩。
- **服务器推送**：支持服务器未经请求，主动向客户端发送资源，即服务器推送
- **请求优先级**： 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验



## **HTTP版本之间差异**

### **HTTP 0.9**

最初的版本，只有一个`GET`请求，只支持纯文本内容

### **HTTP 1.0**

- 任何格式内容都能发送，使互联网不仅可以传输文字，还能传输图像、视频、二进制文件
- 除了`GET`，增加了`POST`和`HEAD`命令
- `http`请求和响应格式改变，除了数据部分，每次通信都必须包括头信息（`header`）用来描述一些元数据
- 只是用`header`中的 `If-Modified-Since` 和 `Expires` 作为缓存失效的标准
- 不支持断点续传，每次都会传送全部页面和数据
- 每台计算机只能绑定一个 `IP` ，所以请求消息中的 `URL` 并没有传递主机名（hostname）

### **HTTP 1.1**

目前最为主流的 `http` 协议版本，从99年发布至今，仍是主流

- 引入了持久连接（`persistent connection`），即 `TCP` 连接默认不关闭，可以被多个请求复用，不用声明 `Connection: keep-alive` 。长连接的连接时长可以通过请求头中的 `keep-alive` 来设置
- 引入了管道机制（`pipelining`），即在同一个 `TCP` 连接里，客户端可以同时发送多个请求，进一步改进了 `HTTP` 协议的效率
- `HTTP 1.1` 中新增加了 `E-tag，If-Unmodified-Since, If-Match, If-None-Match` 等缓存控制标头来控制缓存失效。
- 支持断点续传，通过使用请求头中的 `Range` 来实现。
- 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（`Multi-homed Web Servers`），并且它们共享一个 `IP` 地址。
- 新增方法：`PUT、 PATCH、 OPTIONS、 DELETE`。

### **HTTP 1.x问题**

- 在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。
- `HTTP/1.1` 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。
- `HTTP/1.x` 版本支持 `Keep-alive`，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，对于单文件被不断请求的服务，`Keep-alive` 会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

### **HTTP 2.0**

- **二进制分帧**：头信息和数据体都是二进制，统称为“帧”，头部信息帧和数据帧。将请求及响应包含的信息拆分为多个帧，对其顺序标识后乱序发送，首部封装到 `HEADER frame` 中，请求体封装到 `DATA frame` 中，各帧之间互不依赖、互不干扰
- **多路复用**：复用 `TCP` 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。
- **头部压缩**： `HTTP 1.1` 版本会出现 `「User-Agent、Cookie、Accept、Server、Range」` 等字段可能会占用几百甚至几千字节，而 `Body` 却经常只有几十字节，所以导致头部偏重。`HTTP 2.0` 使用 `HPACK` 算法进行压缩。
- **服务器推送**：支持服务器未经请求，主动向客户端发送资源，即服务器推送
- **请求优先级**： 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验

### http1.1管道机制 vs htttp2.0 多路复用

![img](../http/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTUzMTA2Mi8yMDE5MDYvMTUzMTA2Mi0yMDE5MDYxNzIwMjIzOTA4MC0xMTI4NTI0MjgxLnBuZw)

- 图中第一种请求方式，就是单次发送request请求，收到response后再进行下一次请求，显示是很低效的。
- 于是http1.1提出了**管线化(pipelining)技术**，就是如图中第二中请求方式，**一次性发送多个request**请求。
- 然而pipelining在接收response返回时，也必须依顺序接收，如果前一个请求遇到了阻塞，后面的请求即使已经处理完毕了，仍然需要等待阻塞的请求处理完毕。这种情况就如图中第三种，第一个请求阻塞后，后面的请求都需要等待，这也就是队头阻塞(Head of line blocking)。
- 为了解决上述阻塞问题，http2中提出了多路复用(Multiplexing)技术，Multiplexing是通信和计算机网络领域的专业名词。http2中**将多个请求复用同一个tcp链接中**，将一个TCP连接分为若干个流（Stream），每个流中可以传输若干消息（Message），每个消息由若干最小的二进制帧（Frame）组成。也就是将每个request-response拆分为了细小的二进制帧Frame，这样即使一个请求被阻塞了，也不会影响其他请求，如图中第四种情况所示。



### **HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？**

- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接
- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，因为传输格式是文本的，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞
- HTTP/2多个请求可同时在一个连接上并行执行（由于支持二进制的格式，可以无序）某个请求任务耗时严重，不会影响到其它连接的正常执行



### 管道机制和长连接的关系

HTTP/1.1允许在持久连接上可选地使用请求管道。这是相对于keep-alive连接的又一性能优化。

即管道机制是基于长连接上的又一个可优化项



### 三、请求方法的区别

- **GET和POST**

1. 从参数角度来看，GET参数通过URL传递，POST参数放在Request Body中
2. 从缓存角度来看，GET请求后浏览器会主动缓存，POST则不会，需要手动设置
3. GET请求参数会被完整保留在浏览器的历史纪录中，POST不会
4. 从编码角度来看，GET只能进行URL编码，只能接收ASCII字符，而POST支持更多的编码类型且不对数据类型限值
5. 浏览器通常限制URL长度在2k字节，大多数服务器最多处理64k字节的URL
6. **从TCP角度来看，GET产生一个TCP数据包，浏览器会把http header和data一并发送，服务器响应200 OK并返回数据；POST产生两个TCP数据包，浏览器先发送http header，服务器响应100 continue，浏览器再发送data，服务器响应200 OK并返回数据（火狐只发送一次）**
7. 从幂等性的角度来看，GET是幂等的，而POST不是

注意：幂等是指，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。[参考这里](https://developer.mozilla.org/zh-CN/docs/Glossary/幂等)

- **PUT和POST**

  PUT和POST方法作用类似，不同在于PUT是幂等的。当多次发送相同的POST请求，服务器上的资源数目可能会增加；而PUT请求后服务器上的资源数目不会增加，每次PUT都会覆盖前一次PUT的资源